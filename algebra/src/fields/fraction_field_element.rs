//! Represents a field element as an element of the fraction field of the original field. The
//! elements of the fraction field are a/b for a,b in the original field, and b != 0. The
//! representation of a FieldElementT b is b/1. Addition and multiplication for the fraction field
//! are defined naturally (see functions operator+ and operator*). The resulting field is identical
//! to the original field. This fractional representation of the original field enables to cheaply
//! perform an inverse operation: the inverse of a/b is simply b/a.
//!
//! mirror: https://github.com/starkware-libs/stone-prover/blob/main/src/starkware/algebra/fields/fraction_field_element.h

use std::{
  cmp::PartialEq,
  collections::VecDeque,
  ops::{Add, AddAssign, Mul, Neg, Sub},
};

// TODO(TK 2024-01-09): temp
pub type GslSpan<T> = VecDeque<T>;

use ark_ff::Field;
use rand::Rng;
use serde::{Deserialize, Serialize};

/// Represents a field element as an element of the fraction field of the original field.
#[derive(Debug, Clone, Eq, Serialize, Deserialize)]
pub struct FractionFieldElement<F: Field> {
  numerator:   F,
  denominator: F,
}

impl<F: Field> FractionFieldElement<F> {
  /// Creates a new FractionFieldElement with the value num/denom.
  pub fn new(numerator: F, denominator: F) -> Self {
    assert!(!denominator.is_zero(), "Denominator can't be zero.");
    Self { numerator, denominator }
  }

  /// Returns the zero element of the fraction field.
  pub fn zero() -> Self { Self::new(F::zero(), F::one()) }

  /// Returns the one element of the fraction field.
  pub fn one() -> Self { Self::new(F::one(), F::one()) }

  /// Returns the inverse of the fraction field element.
  pub fn inverse(&self) -> Self { Self::new(self.denominator, self.numerator) }

  /// Converts this fraction field element to the equivalent element in the original field.
  pub fn to_base_field_element(&self) -> F {
    self.numerator
      * self.denominator.inverse().expect("denominator is non-invertible: {self.denominator}")
  }

  // NOTE: to_string, from_string replaced with serde::serialize, serde::deserialize
  // TODO(TK 2024-01-09): to and from bytes option to implement later
  // https://github.com/starkware-libs/stone-prover/blob/00b274b55c82077184be4c0758f7bed18950eaba/src/starkware/algebra/fields/fraction_field_element.h#L88

  /// Returns a fraction field element: its numerator is a random F generated by
  /// Field and its denominator is F::one().
  // TODO(TK 2024-01-09): audit crypto rng
  pub fn random_element(mut rng: impl Rng) -> Self {
    let denominator = F::one();
    let numerator = F::rand(&mut rng);
    Self { numerator, denominator }
  }

  // TODO(TK 2024-01-09): will need to replace Field with either PrimeField or FftField
  // to have access to generator method
  // https://docs.rs/ark-ff/latest/ark_ff/fields/models/fp/trait.FpConfig.html?search=generator#associatedconstant.GENERATOR
  // pub fn field_size(&self) -> usize {
  //   let a = Self::<F>::generator();
  //   todo!()
  //  }
  // pub fn generator(&self) -> Self { todo!() }

  // TODO(TK 2024-01-09): prime_factors, size_in_bytes unimplemented

  // NOTE: the following two methods seem like C++ cruft
  /// Given a list of field elements {a/b}, converts each element to a base field element
  /// a*b^-1.
  /// Divergence: remove output argument; explicitly return output, and renamed
  pub fn vec_to_base_field_element(input: GslSpan<FractionFieldElement<F>>) -> GslSpan<F> {
    input.iter().map(Self::to_base_field_element).collect()
  }

  /// Given a matrix of field elements [[a/b]], converts each element to a base field element
  /// a*b^-1.
  /// Divergence: remove output argument; explicitly return output, and renamed
  pub fn batch_to_base_field_element(
    input: GslSpan<GslSpan<FractionFieldElement<F>>>,
  ) -> GslSpan<GslSpan<F>> {
    input.iter().cloned().map(|col| Self::vec_to_base_field_element(col)).collect()
  }
}

impl<F: Field> From<F> for FractionFieldElement<F> {
  fn from(elem: F) -> Self { Self::new(elem, F::one()) }
}

impl<F: Field> std::fmt::Display for FractionFieldElement<F> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(f, "{}/{}", self.numerator, self.denominator)
  }
}

impl<F: Field> AddAssign for FractionFieldElement<F> {
  fn add_assign(&mut self, rhs: Self) {
    self.numerator = self.numerator * rhs.denominator + rhs.numerator * self.denominator;
    self.denominator *= rhs.denominator;
  }
}

impl<F: Field> Add for FractionFieldElement<F> {
  type Output = Self;

  fn add(self, rhs: Self) -> Self::Output {
    let numerator = self.numerator * rhs.denominator + rhs.numerator * self.denominator;
    let denominator = self.denominator * rhs.denominator;
    FractionFieldElement::new(numerator, denominator)
  }
}

impl<F: Field> Neg for FractionFieldElement<F> {
  type Output = Self;

  fn neg(self) -> Self::Output { Self::new(self.numerator.neg(), self.denominator) }
}

impl<F: Field> Sub for FractionFieldElement<F> {
  type Output = Self;

  fn sub(self, rhs: Self) -> Self::Output { self + (-rhs) }
}

impl<F: Field> Mul for FractionFieldElement<F> {
  type Output = Self;

  fn mul(self, rhs: Self) -> Self::Output {
    let numerator = self.numerator * rhs.numerator;
    let denominator = self.denominator * rhs.denominator;
    FractionFieldElement::new(numerator, denominator)
  }
}

impl<F: Field> PartialEq for FractionFieldElement<F> {
  fn eq(&self, rhs: &Self) -> bool {
    self.numerator * rhs.denominator == rhs.numerator * self.denominator
  }
}
